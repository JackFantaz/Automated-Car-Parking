/*
 *   Automated Car-Parking
 *   EXECUTABLE MODEL AS A RESULT OF SPRINT 1
 *   by Giacomo Fantazzini and Claudia Badalamenti
 *
 * */

System carparking

Dispatch goto : goto(PLACE)
Dispatch movementDone : movementDone(N)
Dispatch notice : notice(NOTICE)
Dispatch slotnum : slotnum(SLOTNUM)
Dispatch tokenid : tokenid(TOKENID)
Dispatch cmd : cmd(MOVE)

Event outdoorCleared : outdoorCleared(N)
Event outdoorOccupied : outdoorOccupied(N)
Event indoorCleared : indoorCleared(N)
Event indoorOccupied : indoorOccupied(N)

Request step : step(TIME)
Reply stepdone : stepdone(V)

Context ctxcarparking ip[host="localhost" port=60000]
Context ctxbasicrobot ip [host="127.0.0.1" port=8020]

ExternalQActor basicrobot context ctxbasicrobot

QActor parkmanagerserviceactor context ctxcarparking {

    [# var slotnum = 1 #]

    State moveToHome_enter initial {
    	delay 1000
        forward trolleyactor -m goto : goto(home)
    } Transition t whenEvent indoorOccupied -> acceptIN // enter request
	
    State moveToHome_exit {
    	delay 1000
        forward trolleyactor -m goto : goto(home)
    } Transition t whenTime 5000 -> acceptOUT // exit request with TOKENID
                  
    State acceptIN {
        forward parkserviceguiactor -m notice : notice(enter_request_accepted)
    } Goto informIN // if INDOOR-area free else moveToHome

    State informIN {
        if [# slotnum > 0 #] {
        	forward parkserviceguiactor -m slotnum : slotnum(1)
        	// slotnum--
        }
    } Goto moveToIn if [# slotnum > 0 #] else moveToHome_enter

    State moveToIn {
        forward trolleyactor -m goto : goto(indoor)
    } Transition t whenMsg movementDone -> receipt            

    State receipt {
    	delay 1000
        forward parkserviceguiactor -m tokenid : tokenid(1)
    } Goto moveToSlotIn

    State moveToSlotIn {
        forward trolleyactor -m goto : goto(parking)
    } Transition t whenMsg movementDone -> moveToHome_exit

    State acceptOUT {
        forward parkserviceguiactor -m notice : notice(exit_request_accepted)
    } Goto findSlot

	State findSlot {
		forward parkserviceguiactor -m notice : notice(carslotnum_1)
		// slotnum++
    } Goto moveToSlotOut

    State moveToSlotOut {
        forward trolleyactor -m goto : goto(parking)
    } Transition t whenMsg movementDone -> moveToOut

    State moveToOut {
    	delay 1000
        forward trolleyactor -m goto : goto(outdoor)
    } Transition t whenMsg movementDone -> moveToHome_enter

}

QActor trolleyactor context ctxcarparking {

	[#
		var planner = carparking.DirectionalPlanner("parkingMap")
		var home = arrayOf("-", "-", "-")
		var parking = arrayOf("-", "-", "-")
		var indoor = arrayOf("-", "-", "-")
		var outdoor = arrayOf("-", "-", "-")
		var goingHome = false
	#]

	State setup initial {
		solve( consult("locationsKb.pl") )
		solve( home(X, Y, D) )
		[# home = arrayOf(getCurSol("X").toString(), getCurSol("Y").toString(), getCurSol("D").toString().toUpperCase()) #]
		solve( parking(X, Y, D) )
		[# parking = arrayOf(getCurSol("X").toString(), getCurSol("Y").toString(), getCurSol("D").toString().toUpperCase()) #]
		solve( indoor(X, Y, D) )
		[# indoor = arrayOf(getCurSol("X").toString(), getCurSol("Y").toString(), getCurSol("D").toString().toUpperCase()) #]
		solve( outdoor(X, Y, D) )
		[# outdoor = arrayOf(getCurSol("X").toString(), getCurSol("Y").toString(), getCurSol("D").toString().toUpperCase()) #]
	} Transition t whenMsg goto -> idle

	State idle {
		onMsg (goto : goto(home)) {
			run planner.planFor(home)
			[# goingHome = true #]
		}
		onMsg (goto : goto(parking)) {
			run planner.planFor(parking)
			[# goingHome = false #]
		}
		onMsg (goto : goto(outdoor)) {
			run planner.planFor(outdoor)
			[# goingHome = false #]
		}
		onMsg (goto : goto(indoor)) {
			run planner.planFor(indoor)
			[# goingHome = false #]
		}
	} Goto working
	
	State working {
		[# val move = planner.getNextPlannedMove() #]
		if [# move.isNotEmpty() #] {
			if [# move == "w" #] { request basicrobot -m step : step(350) }
			if [# move == "l" #] { forward basicrobot -m cmd : cmd(l) }
			if [# move == "r" #] { forward basicrobot -m cmd : cmd(r) }
			run planner.updateMap(move)
		} else {
			if [# !goingHome #] {
				forward parkmanagerserviceactor -m movementDone : movementDone(0)
			}
		}
	} Transition t
		whenTime 450 -> working
		whenReply stepdone -> working
		whenMsg goto -> idle
	
}

QActor parkserviceguiactor context ctxcarparking {
    State receive initial {
        onMsg (slotnum : slotnum(SLOTNUM)) { println("Client's GUI -> The SLOTNUM is: ${payloadArg(0)}") }
        onMsg (tokenid : tokenid(TOKENID)) { println("Client's GUI -> The TOKENID is: ${payloadArg(0)}") }
        onMsg (notice : notice(MESSAGE)) { println("Client's GUI -> Notice received: ${payloadArg(0)}") }
    } Transition t
    	whenMsg slotnum -> receive
    	whenMsg tokenid -> receive
    	whenMsg notice -> receive
}

CodedQActor weightactor context ctxcarparking className "carparking.WeightActor"
